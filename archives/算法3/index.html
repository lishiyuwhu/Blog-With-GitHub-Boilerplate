<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Plams,blog" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Galileo" />
    <link rel="alternate" type="application/rss+xml" title="Plams的个人博客 &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Plams的个人博客 &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/galileo-3f4dcc35c9.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/katex.min.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700&display=swap">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/e0d69042167dbd8719da43b3a14736d2.json"
        }
    </script>
    
<title>算法3 - Plams的个人博客</title>
<meta name="author" content="" />
<meta name="description" content="BFS走迷宫" />
<meta property="og:title" content="算法3 - Plams的个人博客" />
<meta property="og:description" content="BFS走迷宫" />
<meta property="og:site_name" content="Plams的个人博客" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/算法3/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2018-04-03T16:01:00-00.00" />
<meta name="twitter:title" content="算法3 - Plams的个人博客" />
<meta name="twitter:description" content="BFS走迷宫" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />

    </head>
    
    <body>
        
        <div class="container">
            <header id="ga-header">
                <div first>
                    <aside id="ga-brand">
                        <h1 class="brand"><a class="no-style" href="/">Plams的个人博客</a></h1>
                        <p>Destination Determination Deliberation</p>
                    </aside>
                </div>
                <div second id="ga-nav">
                    <nav class="navs">
                        <ul><li><a class="ga-highlight" href="/" target="_self">首页</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/archives/" target="_self">归档</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/about/" target="_self">关于</a></li><span class="separator">·</span><li><a href="#" target="_self" class="search-form-input ga-highlight">搜索</a></li></ul>
                    </nav>
                </div>
            </header>
            <div class="wrapper">
                
<main>    
    <section class="ga-section ga-content">
        <article class="yue">
            <h1 class="ga-post_title">算法3</h1>
            <span class="ga-post_meta ga-mono">
                <span></span>
                <time>
                    2018-04-03
                </time>
                
                in <a no-style class="category" href="/category/Default/">
                    Default
                </a>
                
                
            </span>
            <div class="ga-content_body">
                <h2>BFS走迷宫</h2>
<!-- more -->


<p>题目描述
给定一个 n 行 m 列的地牢，其中 '.' 表示可以通行的位置，'X' 表示不可通行的障碍，牛牛从 (x0 , y0 ) 位置出发，遍历这个地牢，和一般的游戏所不同的是，他每一步只能按照一些指定的步长遍历地牢，要求每一步都不可以超过地牢的边界，也不能到达障碍上。地牢的出口可能在任意某个可以通行的位置上。牛牛想知道最坏情况下，他需要多少步才可以离开这个地牢。
输入描述:
每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 &lt;= n, m &lt;= 50），表示地牢的长和宽。接下来的 n 行，每行 m 个字符，描述地牢，地牢将至少包含两个 '.'。接下来的一行，包含两个整数 x0, y0，表示牛牛的出发位置（0 &lt;= x0 &lt; n, 0 &lt;= y0 &lt; m，左上角的坐标为 （0, 0），出发位置一定是 '.'）。之后的一行包含一个整数 k（0 &lt; k &lt;= 50）表示牛牛合法的步长数，接下来的 k 行，每行两个整数 dx, dy 表示每次可选择移动的行和列步长（-50 &lt;= dx, dy &lt;= 50）
输出描述:
输出一行一个数字表示最坏情况下需要多少次移动可以离开地牢，如果永远无法离开，输出 -1。以下测试用例中，牛牛可以上下左右移动，在所有可通行的位置.上，地牢出口如果被设置在右下角，牛牛想离开需要移动的次数最多，为3次。</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;numeric&gt;
#include &lt;algorithm&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;
#include &lt;queue&gt;
using namespace std;

typedef long long ll;

int n, m;
int direction[55][2];
int dcnt;
char ground[55][55];
int dis[55][55];

struct Point{
    int x,y;
    Point(){};
    Point(int _x, int _y): x(_x), y(_y){}
    Point go(int idx){
        return Point(x+direction[idx][0], y+direction[idx][1]);
    }
    bool isOK(){
        return x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&lt;n &amp;&amp; ground[x][y]=='.';
    }
};

int main(){
    scanf("%d%d", &amp;n,&amp;m);
    for(int i=0;i&lt;n;++i)
        scanf("%s",ground[i]);

    Point start;
    scanf("%d%d", &amp;start.x, &amp;start.y);
    scanf("%d", &amp;dcnt);
    for(int i=0; i&lt;dcnt;++i)
        scanf("%d%d", &amp;direction[i][0], &amp;direction[i][1]);
    fill(dis[0], dis[54]+55, INT_MAX);
    dis[start.x][start.y]=0;

    queue&lt;Point&gt; q;
    q.push(start);
    while(!q.empty()){
        Point x=q.front();
        q.pop();
        for(int i=0; i&lt;dcnt; ++i){
            Point y=x.go(i);
            if(y.isOK()){
                if(dis[y.x][y.y]&gt;dis[x.x][x.y]+1){
                    dis[y.x][y.y]=dis[x.x][x.y]+1;
                    q.push(y);
                }

            }
        }
    }

    int ans=0;
    for(int i=0; i&lt;n; ++i){
        for(int j=0; j&lt;m; ++j){
            if(ground[i][j]=='.') ans=max(ans, dis[i][j]);
        }
    }

    printf("%d\n", ans==INT_MAX?-1:ans);
    return 0;
}</code></pre>
<h2>BFS走迷宫</h2>
<p>题目描述
小青蛙有一天不小心落入了一个地下迷宫,小青蛙希望用自己仅剩的体力值P跳出这个地下迷宫。为了让问题简单,假设这是一个n*m的格子迷宫,迷宫每个位置为0或者1,0代表这个位置有障碍物,小青蛙达到不了这个位置;1代表小青蛙可以达到的位置。小青蛙初始在(0,0)位置,地下迷宫的出口在(0,m-1)(保证这两个位置都是1,并且保证一定有起点到终点可达的路径),小青蛙在迷宫中水平移动一个单位距离需要消耗1点体力值,向上爬一个单位距离需要消耗3个单位的体力值,向下移动不消耗体力值,当小青蛙的体力值等于0的时候还没有到达出口,小青蛙将无法逃离迷宫。现在需要你帮助小青蛙计算出能否用仅剩的体力值跳出迷宫(即达到(0,m-1)位置)。
输入描述:
输入包括n+1行:
 第一行为三个整数n,m(3 &lt;= m,n &lt;= 10),P(1 &lt;= P &lt;= 100)
 接下来的n行:
 每行m个0或者1,以空格分隔
输出描述:
如果能逃离迷宫,则输出一行体力消耗最小的路径,输出格式见样例所示;如果不能逃离迷宫,则输出"Can not escape!"。 测试数据保证答案唯一</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="cm">/*</span>
<span class="cm"> * 声明：这份代码是照搬@null_ptr的 但是代码没什么注释，乍一看不好理解，</span>
<span class="cm"> * 所以我作了比较详细的注释，方便参考</span>
<span class="cm"> * 基本思想：典型的迷宫问题，DFS穷举所有路径，找出剩余体力最多的路径</span>
<span class="cm"> */</span>
 
<span class="cp">#define VISITED 2</span>
 
 
<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">P</span><span class="p">;</span>        <span class="c1">// 输入m，n，P</span>
<span class="kt">int</span> <span class="n">maze</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">];</span>   <span class="c1">// 迷宫地图</span>
<span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">-1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">-1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>     <span class="c1">// 左，右，上，下移动，例如：{0, -1}代表向左移动一步</span>
<span class="kt">int</span> <span class="n">cost</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">-1</span><span class="p">,</span> <span class="mi">-1</span><span class="p">,</span> <span class="mi">-3</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>    <span class="c1">// 左，右，上，下移动的体力消耗，例如：{0， -1}对应-1</span>
<span class="kt">int</span> <span class="n">final_P</span> <span class="o">=</span> <span class="mi">-200</span><span class="p">;</span>    <span class="c1">// 剩余的体力值，初始为较小的数，保证final_P被正确更新</span>
 
<span class="c1">// 存储各点的数据结构</span>
<span class="k">struct</span> <span class="nc">mazePoint</span> <span class="p">{</span>
    <span class="n">mazePoint</span><span class="p">(</span><span class="kt">int</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_y</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 存储每次遍历到的路径</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">mazePoint</span><span class="o">&gt;</span> <span class="n">pathStack</span><span class="p">;</span>
<span class="c1">// 存储最终的最优路径</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">mazePoint</span><span class="o">&gt;</span> <span class="n">minCostPath</span><span class="p">;</span>
 
<span class="c1">// 函数：打印路径</span>
<span class="kt">void</span> <span class="nf">printPath</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">mazePoint</span><span class="o">&gt;&amp;</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="c1">// 函数：寻找最优路径</span>
<span class="kt">void</span> <span class="nf">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cur_P</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 将当前点加入路径并标记为VISITED</span>
    <span class="n">pathStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mazePoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
    <span class="n">maze</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">VISITED</span><span class="p">;</span>
     
    <span class="c1">// 如果当前点为出口且当前体力值&gt;=0，则更新final_P与minCostPath，并返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="mi">-1</span> <span class="o">&amp;&amp;</span> <span class="n">cur_P</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur_P</span> <span class="o">&gt;</span> <span class="n">final_P</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">final_P</span> <span class="o">=</span> <span class="n">cur_P</span><span class="p">;</span>
            <span class="n">minCostPath</span> <span class="o">=</span> <span class="n">pathStack</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pathStack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>   <span class="c1">// 为了回退至之前的节点，将当前结点弹出</span>
        <span class="n">maze</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// 注意：之前maze[x][y]被标记为VISITED（值为2），回退后应该将其还原为1</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
     
    <span class="c1">// 如果当前点并非出口且当前体力值&gt;=0，则分别向左右上下四个方向探索，并计算相应的消耗</span>
    <span class="c1">// 如果新的点再边界内且为可达点，递归调用search函数</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cur_P</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">nP</span> <span class="o">=</span> <span class="n">cur_P</span> <span class="o">+</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">maze</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">search</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nP</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
     
    <span class="n">pathStack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>    <span class="c1">// 为了回退至之前的节点，将当前结点弹出</span>
    <span class="n">maze</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// 注意：之前maze[x][y]被标记为VISITED（值为2），回退后应该将其还原为1</span>
<span class="p">}</span>
 
<span class="c1">// 主函数</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">P</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
     
    <span class="n">search</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">P</span><span class="p">);</span>
     
    <span class="k">if</span> <span class="p">(</span><span class="n">final_P</span> <span class="o">!=</span> <span class="mi">-200</span><span class="p">)</span>    <span class="c1">// 如果final_P更新过，输出最优路径</span>
        <span class="n">printPath</span><span class="p">(</span><span class="n">minCostPath</span><span class="p">);</span>
    <span class="k">else</span>    <span class="c1">// 如果final_P为初始值-200，代表其没有被更新过，也就意味着没有可行路径</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Can not escape!&quot;</span><span class="p">;</span>
     
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h2>正则匹配输入</h2>
<p>输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如4 4 4 4-joker JOKER。</p>

<pre><code>scanf("%[^-]-%[^\n]", a, b);</code></pre>
<h2>大整数运算与进制转换</h2>
<p><a href="https://blog.kedixa.top/2017/cpp-bigint-overview/">https://blog.kedixa.top/2017/cpp-bigint-overview/</a></p>
<h2>简单进制转换</h2>
<p>写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ）</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int a;
    while(cin&gt;&gt;hex&gt;&gt;a){
    cout&lt;&lt;a&lt;&lt;endl;
    }
}</code></pre>
<h2>游历魔法王国</h2>
<p>魔法王国一共有n个城市,编号为0~n-1号,n个城市之间的道路连接起来恰好构成一棵树。
小易现在在0号城市,每次行动小易会从当前所在的城市走到与其相邻的一个城市,小易最多能行动L次。
如果小易到达过某个城市就视为小易游历过这个城市了,小易现在要制定好的旅游计划使他能游历最多的城市,请你帮他计算一下他最多能游历过多少个城市(注意0号城市已经游历了,游历过的城市不重复计算)。</p>
<p>思路：分两种情况讨论</p>
<p>　　　　一是当小易走的步数小于树的最长链</p>
<p>　　　　二是当小易走的步数大于最长链</p>
<p>　　　　　　这时候 最长链是一定要走的 那剩下的步数最优的情况是走一步走过的城市 再到一个没走过的城市 再退回来 再走没走的城市</p>
<p>　　　　　　这样最多可以走(L-MAX_L)/2个城市</p>
<p>　　　　最后min(n,MAX_L+(L-MAX_L)/2)</p>

<pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
const int maxn = 50 + 5;
int n, L;
int parent[maxn];
int dp[200];
int main() {
    scanf("%d%d", &amp;n, &amp;L);
    for(int i = 0; i &lt; n - 1; i++) scanf("%d", &amp;parent[i]);
    int mx = 0;
    for(int i = 0; i &lt; n - 1; i++) {
        dp[i + 1] = dp[parent[i]] + 1;
        mx = max(mx, dp[i + 1]);
    }
    int d = min(L, mx);
    cout &lt;&lt; min((n), 1 + d + (L - d) / 2) &lt;&lt; endl;
    return 0;
}</code></pre>

            </div>
        </article>
        <div id="ga-tags">
    
</div>
    </section>

    
<section id="ga-content_pager">

    <div class="next">
        <a class="ga-highlight" href="/archives/算法4/">算法4</a>
        <p class="yue">01背包</p>
    </div>


    <div class="prev">
        <a class="ga-highlight" href="/archives/算法2/">算法2</a>
        <p class="yue">顺时针打印矩阵</p>
    </div>

</section>


    

</main>

                <footer class="ga-mono" id="ga-footer">
                    <section>
                        <span id="ga-uptime"></span>
                        <span class="brand">Plams的个人博客</span>
                    </section>
                    <section>
                        <p class="copyright">
                            <span>Copyright © 2021 Plams</span>
                            <span>Powered by <a no-style href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Galileo</a></span>
                        </p>
                        <div class="copyright">
                            <span class="footer-addon">
                                
                            </span>
                            <nav class="social-links">
                                <ul><li><a class="no-style" title="GitHub" href="https://github.com/lishiyuwhu" target="_blank"><i class="gi gi-github"></i>GitHub</a></li></ul>
                            </nav>
                        </div>
                    </section>
                    <script>
                        var site_build_date = "2018-3-28T16:16+08:00"
                    </script>
                    <script src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/galileo-dc4baa7cf4.js"></script>
                </footer>
            </div>
        </div>
    </div>

    <!--katex-->
    <script defer src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/katex.min.js"></script>
    <script>
    mathOpts = {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\[", right: "\\]", display: true},
            {left: "$", right: "$", display: false},
            {left: "\\(", right: "\\)", display: false}
        ]
    };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    <script src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    
    </body>
</html>