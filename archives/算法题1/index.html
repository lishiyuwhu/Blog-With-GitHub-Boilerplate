<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Plams,blog" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Galileo" />
    <link rel="alternate" type="application/rss+xml" title="Plams的个人博客 &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Plams的个人博客 &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/galileo-3f4dcc35c9.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/katex.min.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700&display=swap">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/e0d69042167dbd8719da43b3a14736d2.json"
        }
    </script>
    
<title>算法题1 - Plams的个人博客</title>
<meta name="author" content="" />
<meta name="description" content="从尾到头打印链表" />
<meta property="og:title" content="算法题1 - Plams的个人博客" />
<meta property="og:description" content="从尾到头打印链表" />
<meta property="og:site_name" content="Plams的个人博客" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/算法题1/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2018-03-29T16:16:00-00.00" />
<meta name="twitter:title" content="算法题1 - Plams的个人博客" />
<meta name="twitter:description" content="从尾到头打印链表" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />

    </head>
    
    <body>
        
        <div class="container">
            <header id="ga-header">
                <div first>
                    <aside id="ga-brand">
                        <h1 class="brand"><a class="no-style" href="/">Plams的个人博客</a></h1>
                        <p>Destination Determination Deliberation</p>
                    </aside>
                </div>
                <div second id="ga-nav">
                    <nav class="navs">
                        <ul><li><a class="ga-highlight" href="/" target="_self">首页</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/archives/" target="_self">归档</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/about/" target="_self">关于</a></li><span class="separator">·</span><li><a href="#" target="_self" class="search-form-input ga-highlight">搜索</a></li></ul>
                    </nav>
                </div>
            </header>
            <div class="wrapper">
                
<main>    
    <section class="ga-section ga-content">
        <article class="yue">
            <h1 class="ga-post_title">算法题1</h1>
            <span class="ga-post_meta ga-mono">
                <span></span>
                <time>
                    2018-03-29
                </time>
                
                in <a no-style class="category" href="/category/Default/">
                    Default
                </a>
                
                
            </span>
            <div class="ga-content_body">
                <h2>从尾到头打印链表</h2>
<!-- more -->

<p>输入一个链表，从尾到头打印链表每个节点的值。</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">*  struct ListNode {</span>
<span class="cm">*        int val;</span>
<span class="cm">*        struct ListNode *next;</span>
<span class="cm">*        ListNode(int x) :</span>
<span class="cm">*              val(x), next(NULL) {</span>
<span class="cm">*        }</span>
<span class="cm">*  };</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">printListFromTailToHead</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">printListFromTailToHead</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2>重建二叉树</h2>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>

<span class="cm">     * Definition for binary tree</span>

<span class="cm">     * struct TreeNode {</span>

<span class="cm">     *     int val;</span>

<span class="cm">     *     TreeNode *left;</span>

<span class="cm">     *     TreeNode *right;</span>

<span class="cm">     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span>

<span class="cm">     * };</span>

<span class="cm">     */</span>

    <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>

    <span class="k">public</span><span class="o">:</span>

        <span class="k">struct</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pre</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">)</span> <span class="p">{</span>

            <span class="kt">int</span> <span class="n">inlen</span><span class="o">=</span><span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

            <span class="k">if</span><span class="p">(</span><span class="n">inlen</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">left_pre</span><span class="p">,</span><span class="n">right_pre</span><span class="p">,</span><span class="n">left_in</span><span class="p">,</span><span class="n">right_in</span><span class="p">;</span>

            <span class="c1">//创建根节点，根节点肯定是前序遍历的第一个数</span>

            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">head</span><span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

            <span class="c1">//找到中序遍历根节点所在位置,存放于变量gen中</span>

            <span class="kt">int</span> <span class="n">gen</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">inlen</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>

            <span class="p">{</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="p">{</span>

                    <span class="n">gen</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>

                    <span class="k">break</span><span class="p">;</span>

                <span class="p">}</span>

            <span class="p">}</span>

            <span class="c1">//对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边</span>

            <span class="c1">//利用上述这点，对二叉树节点进行归并</span>

            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">gen</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>

            <span class="p">{</span>

                <span class="n">left_in</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

                <span class="n">left_pre</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span><span class="c1">//前序第一个为根节点</span>

            <span class="p">}</span>

            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">gen</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">inlen</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>

            <span class="p">{</span>

                <span class="n">right_in</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

                <span class="n">right_pre</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="p">}</span>

            <span class="c1">//和shell排序的思想类似，取出前序和中序遍历根节点左边和右边的子树</span>

            <span class="c1">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span>

           <span class="n">head</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">=</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">left_pre</span><span class="p">,</span><span class="n">left_in</span><span class="p">);</span>

           <span class="n">head</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">=</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">right_pre</span><span class="p">,</span><span class="n">right_in</span><span class="p">);</span>

           <span class="k">return</span> <span class="n">head</span><span class="p">;</span>

        <span class="p">}</span>

    <span class="p">};</span>
</pre></div>
<h2>用两个栈来实现一个队列</h2>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stack1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stack1</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
            <span class="n">stack2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stack1</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
            <span class="n">stack1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">stack2</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
            <span class="n">stack1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
            <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stack1</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stack2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>麻烦一点就是:
栈s1和栈s2，栈s1专门为入队，栈s2专门为出队。</p>
<p>入队：</p>
<p>当s1和s2都为空时，直接入队s1。
当s1为空，s2不为空时，把s2的元素都倒回s1，然后再入队s1
出队：</p>
<p>当s2不为空时，直接出队s2
当s2为空且s1不为空时，把s1的元素都倒进s2，然后出队s2</p>
<h2>旋转数组的最小数字</h2>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba">https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba</a>
来源：牛客网</p>
<p>旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素</p>
<p>注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。</p>
<p>思路：</p>
<p>（1）我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。</p>
<p>但是如果不是旋转，第一个元素肯定小于最后一个元素。</p>
<p>（2）找到数组的中间元素。</p>
<p>中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。</p>
<p>移动之后，第一个指针仍然位于前面的递增数组中。</p>
<p>中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。</p>
<p>移动之后，第二个指针仍然位于后面的递增数组中。</p>
<p>这样可以缩小寻找的范围。</p>
<p>（3）按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。</p>
<p>最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。</p>
<p>也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。</p>
<p>到目前为止以上思路很耗的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。</p>
<p>因此这一道题目比上一道题目多了些特殊情况：</p>
<p>我们看一组例子：｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。</p>
<p>这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。</p>
<p>第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。</p>
<p>因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。</p>
<p>也就无法移动指针来缩小查找的范围。</p>
<h2>动规斐波那契</h2>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。
n&lt;=39</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">Fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">){</span>
            <span class="n">g</span> <span class="o">+=</span> <span class="n">f</span><span class="p">;</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">g</span><span class="o">-</span><span class="n">f</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2>青蛙跳台阶</h2>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>先数学归纳, 再直接输出</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">jumpFloorII</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">&lt;&lt;--</span><span class="n">number</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</h2>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。
举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>

<pre><code>class Solution {
public:
     int  NumberOf1(int n) {
         int count = 0;
          while(n){
              int temp = n-1;
              n = n &amp; temp;
              ++count;
          }
         return count;
     }
};</code></pre>
<h2>double的幂</h2>
<p>1.当底数为0且指数&lt;0时 会出现对0求倒数的情况，需进行错误处理；
2.判断底数是否等于0 由于base为double型，不能直接用==判断</p>
<p>要判断一个单精度浮点数：则是if( abs(f) &lt;= 1e-6)；
要判断一个双精度浮点数：则是if( abs(f) &lt;= 1e-15 )；</p>
<p>使用快速幂</p>

<pre><code>class Solution {
public:
    double Power(double base, int exponent) {
        if ((abs(base)&lt; 1e-15) &amp;&amp; exponent==0)
            return 1;
        else if (abs(base)&lt;1e-15 &amp;&amp; exponent&gt;0)
            return 0;
        else if (abs(base)&lt;1e-15 &amp;&amp; exponent&lt;0)
            return NAN;

        double ans = 1.0;
        int p = abs(exponent);
        while(p){
            if(p%2)
                ans *= base;
            base  *= base;
            p &gt;&gt;=1;
        }
        return (exponent&gt;0)? ans: 1/ans;
    }
};</code></pre>
<h2>调整数组顺序使奇数位于偶数前面</h2>
<div class="highlight"><pre><span></span><span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span><span class="n">c</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<h2>链表就地逆置</h2>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct ListNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct ListNode *next;</span>
<span class="cm">    ListNode(int x) :</span>
<span class="cm">            val(x), next(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">ReverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">pHead</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">p</span><span class="o">=</span><span class="n">pHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2>有序链表的merge</h2>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>递归版本</p>

<pre><code>/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        ListNode* result = NULL;
        ListNode* current = NULL;
        if (pHead1==NULL)
            return pHead2;
        if (pHead2 == NULL)
            return pHead1;
        if(pHead1-&gt;val &lt;= pHead2-&gt;val){
            result = pHead1;
            result-&gt;next = Merge(pHead1-&gt;next, pHead2);
        }
        else {
            result = pHead2;
            result-&gt;next = Merge(pHead1, pHead2-&gt;next);
        }
        return result;
    }
};</code></pre>
<p>非递归正常写</p>

<pre><code>public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        //新建一个头节点，用来存合并的链表。
        ListNode head=new ListNode(-1);
        head.next=null;
        ListNode root=head;
        while(list1!=null&amp;&amp;list2!=null){
            if(list1.val&lt;list2.val){
                head.next=list1;
                head=list1;
                list1=list1.next;
            }else{
                head.next=list2;
                head=list2;
                list2=list2.next;
            }
        }
        //把未结束的链表连接到合并后的链表尾部
        if(list1!=null){
            head.next=list1;
        }
        if(list2!=null){
            head.next=list2;
        }
        return root.next;
    }
}</code></pre>
<h2>树的子结构</h2>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct TreeNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct TreeNode *left;</span>
<span class="cm">    struct TreeNode *right;</span>
<span class="cm">    TreeNode(int x) :</span>
<span class="cm">            val(x), left(NULL), right(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">is_contain</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">t1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">t2</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t2</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t1</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">t2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">is_contain</span><span class="p">(</span><span class="n">t1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">t2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_contain</span><span class="p">(</span><span class="n">t1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">t2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">HasSubtree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">pRoot1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pRoot2</span><span class="p">)</span>
    <span class="p">{</span>


        <span class="k">if</span><span class="p">(</span><span class="n">pRoot1</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">||</span> <span class="n">pRoot2</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">is_contain</span><span class="p">(</span><span class="n">pRoot1</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_contain</span><span class="p">(</span><span class="n">pRoot1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_contain</span><span class="p">(</span><span class="n">pRoot1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<pre><code>            if(t2==NULL)
                return true;
            if(t1==NULL)
                return false;</code></pre>
<p>如果这两个反了就会错误</p>
<h2>二叉树镜像</h2>

<pre><code>/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        if (pRoot==NULL)
            return ;
        TreeNode* tmp;
        tmp = pRoot-&gt;left;
        pRoot-&gt;left = pRoot-&gt;right;
        pRoot-&gt;right = tmp;
        Mirror(pRoot-&gt;left);
        Mirror(pRoot-&gt;right);
    }
};</code></pre>

            </div>
        </article>
        <div id="ga-tags">
    
</div>
    </section>

    
<section id="ga-content_pager">

    <div class="next">
        <a class="ga-highlight" href="/archives/算法2/">算法2</a>
        <p class="yue">顺时针打印矩阵</p>
    </div>


    <div class="prev">
        <a class="ga-highlight" href="/archives/SumatraPDF修改背景色/">SumatraPDF修改背景色</a>
        <p class="yue">图片描述</p>
    </div>

</section>


    

</main>

                <footer class="ga-mono" id="ga-footer">
                    <section>
                        <span id="ga-uptime"></span>
                        <span class="brand">Plams的个人博客</span>
                    </section>
                    <section>
                        <p class="copyright">
                            <span>Copyright © 2021 Plams</span>
                            <span>Powered by <a no-style href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Galileo</a></span>
                        </p>
                        <div class="copyright">
                            <span class="footer-addon">
                                
                            </span>
                            <nav class="social-links">
                                <ul><li><a class="no-style" title="GitHub" href="https://github.com/lishiyuwhu" target="_blank"><i class="gi gi-github"></i>GitHub</a></li></ul>
                            </nav>
                        </div>
                    </section>
                    <script>
                        var site_build_date = "2018-3-28T16:16+08:00"
                    </script>
                    <script src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/galileo-dc4baa7cf4.js"></script>
                </footer>
            </div>
        </div>
    </div>

    <!--katex-->
    <script defer src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/katex.min.js"></script>
    <script>
    mathOpts = {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\[", right: "\\]", display: true},
            {left: "$", right: "$", display: false},
            {left: "\\(", right: "\\)", display: false}
        ]
    };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    <script src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/lishiyuwhu/Blog-With-GitHub-Boilerplate@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    
    </body>
</html>